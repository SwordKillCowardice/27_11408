# 一、绪论
1. 4大件体系
    ![[Pasted image 20260128134847.png]]
2. 区分数据对象和数据结构：**看是否强调关系**
    ![[Pasted image 20260128135506.png]]
3. 计算空间复杂度：**只需考虑额外辅助空间**(如临时数组，通过指针申请的内存，递归调用)
    1. 所需空间示意图
        ![[Pasted image 20260128192442.png]]
    2. **不考虑指令**：因为代码确定后指令就唯一确定了，所用的空间为常数
    3. 不考虑常数和与$n$无关的变量，因为所用空间也是常数
    4. 递归程序
        1. 递归程序中无辅助空间时，复杂度即递归深度
            ![[Pasted image 20260128192943.png]]
        2. 有辅助空间时，逐层分析并求和
            ![[Pasted image 20260128193150.png]]
---
# 二、线性表
1. 使用顺序表实现线性表，并采用**动态空间分配**时。**空间扩容**的函数实现如下：其中*len*代表需要增加的长度
    ![[Pasted image 20260201200153.png]]
2. **结构体变量**不能整个用$==$来比较，**应该对各个分量依次比较**
3. **typedef type \*name**：使name成为type\*的别名，即指针
    ![[Pasted image 20260202154407.png]]
4. 回答**开放题**(比较两个数据结构)的思维框架：先讲共同点，再讲不同点，指出不同点带来的优缺点，并举几个实际操作具体比较
    ![[Pasted image 20260202173908.png]]
---
# 三、栈、队列、数组
1. 示意图
    ![[Pasted image 20260206164435.png]]
    ![[Pasted image 20260206164511.png]]
2. 中缀表达式转后缀表达式
    1. 若中缀表达式运算顺序不唯一，则可以得到的后缀表达式也不唯一
        ![[Pasted image 20260206202209.png]]
    2. 添加**左优先**原则，即可保证结果唯一，从而确保转换算法的**确定性**。左优先原则即：如果**左边的运算可以先进行，那必须先算左边**。比如$A+B+C$,必须先算$A+B$,从而**保证了**运算顺序的唯一性
        ![[Pasted image 20260206202717.png]]
3. 中缀表达式转前缀表达式
    1. 手算方法
        ![[Pasted image 20260206204135.png]]
    2. 用栈实现前缀表达式计算时：**先弹出左操作数，和后缀相反**、**是从右往左扫描，因为每个运算符都和他右边先看到的两个操作数结合**
        ![[Pasted image 20260206204256.png]]
4. 中缀表达式计算算法：同时使用操作数栈和运算符栈，结合中缀转后缀算法和后缀计算算法，逐个字符处理即可
    ![[Pasted image 20260207195748.png]]
5. 后缀表达式：本身是一个**递归结构**：op1 op2 运算符，其中op1和op2都是递归的后缀表达式或数字。后缀表达式**从左往右扫描**，右边的操作数更靠近运算符，所以会先算，即后到先算，故符合栈**LIFO**的特性
6. 函数调用：注意*main*函数之前还有其他内容即可(回忆编译时会连接多个目标文件)
    ![[Pasted image 20260208145232.png]]
7. 使用**十字链表**存储**稀疏矩阵**示意图：建立一个行指针数组和一个列指针数组。每个行指针指向该行第一个非零元节点，列指针则指向该列第一个非零元节点
    ![[Pasted image 20260208200049.png]]
---
# 四、串
1. 解释乱码
    1. 假设目标文件采用编码函数$f(x)$编码，那么它必然采用$f^{-1}(x)$解码
    2. 当你使用某个软件打开目标文件时，该软件可能识别错了$f(x)$，而采用$g^{-1}(x)$解码，故产生乱码
    ![[Pasted image 20260211182052.png]]
2. 串的顺序存储四种方案：教材采用方案四，即结合方案一和方案二。既舍弃第一个存储空间，以确保下标和串位置对应(从1开始)；又采用单独变量*length*记录串长
    ![[Pasted image 20260211182614.png]]
---
# 五、树与二叉树
1. 度为*m*的树和*m*叉树
    ![[Pasted image 20260212173220.png]]
2. 表达式树：遍历顺序和所得序列的关系
    ![[Pasted image 20260215152711.png]]
3. 线索二叉树
    1. 先序线索化的代码：由于是按照根左右的顺序处理，根节点的左指针可能已经是一个线索而不是原来的孩子，此时递归卡死，所以应该加一个标志位判断条件
        ![[Pasted image 20260216141952.png]]
    2. 中序线索化和后序线索化也不会卡死：别忘处理最后一个节点。本质只是加一个指针*pre*并修改先中后序的*visit*函数
        ![[Pasted image 20260216142406.png]]
    3. 有线索二叉树，如何找前驱和后继 
        1. 中序找前驱和后继都方便
        2. 先序线索二叉树找前驱如下(三叉链表找分四类，或者从头遍历)，找后继容易
            ![[Pasted image 20260216145712.png]]
            ![[Pasted image 20260216150146.png]]
        3. 后序线索二叉树找后继如下(三叉分四类)，第三类先左走后右走，找前驱容易
            ![[Pasted image 20260216150112.png]]
            ![[Pasted image 20260216150131.png]]