# 一、绪论
1. 4大件体系
    ![[Pasted image 20260128134847.png]]
2. 区分数据对象和数据结构：**看是否强调关系**
    ![[Pasted image 20260128135506.png]]
3. 计算空间复杂度：**只需考虑额外辅助空间**(如临时数组，通过指针申请的内存，递归调用)
    1. 所需空间示意图
        ![[Pasted image 20260128192442.png]]
    2. **不考虑指令**：因为代码确定后指令就唯一确定了，所用的空间为常数
    3. 不考虑常数和与$n$无关的变量，因为所用空间也是常数
    4. 递归程序
        1. 递归程序中无辅助空间时，复杂度即递归深度
            ![[Pasted image 20260128192943.png]]
        2. 有辅助空间时，逐层分析并求和
            ![[Pasted image 20260128193150.png]]
---
# 二、线性表
1. 使用顺序表实现线性表，并采用**动态空间分配**时。**空间扩容**的函数实现如下：其中*len*代表需要增加的长度
    ![[Pasted image 20260201200153.png]]
2. **结构体变量**不能整个用$==$来比较，**应该对各个分量依次比较**
3. **typedef type \*name**：使name成为type\*的别名，即指针
    ![[Pasted image 20260202154407.png]]
4. 回答**开放题**(比较两个数据结构)的思维框架：先讲共同点，再讲不同点，指出不同点带来的优缺点，并举几个实际操作具体比较
    ![[Pasted image 20260202173908.png]]
---
# 三、栈、队列、数组
1. 示意图
    ![[Pasted image 20260206164435.png]]
    ![[Pasted image 20260206164511.png]]
2. 中缀表达式转后缀表达式
    1. 若中缀表达式运算顺序不唯一，则可以得到的后缀表达式也不唯一
        ![[Pasted image 20260206202209.png]]
    2. 添加**左优先**原则，即可保证结果唯一，从而确保转换算法的**确定性**。左优先原则即：如果**左边的运算可以先进行，那必须先算左边**。比如$A+B+C$,必须先算$A+B$,从而**保证了**运算顺序的唯一性
        ![[Pasted image 20260206202717.png]]
3. 中缀表达式转前缀表达式
    1. 手算方法
        ![[Pasted image 20260206204135.png]]
    2. 用栈实现前缀表达式计算时：**先弹出左操作数，和后缀相反**、**是从右往左扫描，因为每个运算符都和他右边先看到的两个操作数结合**
        ![[Pasted image 20260206204256.png]]
4. 中缀表达式计算算法：同时使用操作数栈和运算符栈，结合中缀转后缀算法和后缀计算算法，逐个字符处理即可
    ![[Pasted image 20260207195748.png]]
5. 后缀表达式：本身是一个**递归结构**：op1 op2 运算符，其中op1和op2都是递归的后缀表达式或数字。后缀表达式**从左往右扫描**，右边的操作数更靠近运算符，所以会先算，即后到先算，故符合栈**LIFO**的特性
6. 函数调用：注意*main*函数之前还有其他内容即可(回忆编译时会连接多个目标文件)
    ![[Pasted image 20260208145232.png]]
7. 使用**十字链表**存储**稀疏矩阵**示意图：建立一个行指针数组和一个列指针数组。每个行指针指向该行第一个非零元节点，列指针则指向该列第一个非零元节点
    ![[Pasted image 20260208200049.png]]
---
# 四、串
1. 